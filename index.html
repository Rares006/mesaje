
</body>
</html><!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="UTF-8">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tabăra 2025</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
min-height: 100vh;
color: #333;
line-height: 1.6;
-webkit-tap-highlight-color: transparent;
-webkit-touch-callout: none;
-webkit-user-select: none;
user-select: none;
}

.container {
max-width: 1200px;
margin: 0 auto;
padding: 10px;
}

.header {
background: rgba(255, 255, 255, 0.95);
backdrop-filter: blur(10px);
border-radius: 20px;
padding: 20px;
margin-bottom: 20px;
text-align: center;
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

.header h1 {
color: #4c63d2;
font-size: 2.2em;
margin-bottom: 10px;
text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
}

.header p {
color: #666;
font-size: 1em;
margin-top: 10px;
}

.nav-tabs {
display: flex;
justify-content: center;
margin-bottom: 20px;
gap: 10px;
flex-wrap: wrap;
padding: 0 10px;
}

.nav-tab {
padding: 12px 20px;
background: rgba(255, 255, 255, 0.2);
border: none;
border-radius: 25px;
cursor: pointer;
font-size: 14px;
font-weight: 600;
color: white;
transition: all 0.3s ease;
backdrop-filter: blur(10px);
border: 2px solid transparent;
min-width: 140px;
touch-action: manipulation;
}

.nav-tab.active {
background: rgba(255, 255, 255, 0.9);
color: #4c63d2;
transform: translateY(-2px);
box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
border-color: #4c63d2;
}

.nav-tab:hover, .nav-tab:active {
transform: translateY(-1px);
box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
background: rgba(255, 255, 255, 0.3);
}

.tab-content {
display: none;
background: rgba(255, 255, 255, 0.95);
border-radius: 20px;
padding: 20px;
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
backdrop-filter: blur(10px);
margin-bottom: 20px;
}

.tab-content.active {
display: block;
animation: fadeIn 0.5s ease-in-out;
}

@keyframes fadeIn {
from { 
    opacity: 0; 
    transform: translateY(20px); 
}
to { 
    opacity: 1; 
    transform: translateY(0); 
}
}

.tab-content h2 {
color: #4c63d2;
margin-bottom: 20px;
font-size: 1.6em;
text-align: center;
}

.form-group {
margin-bottom: 15px;
}

.form-group label {
display: block;
margin-bottom: 8px;
font-weight: 600;
color: #4c63d2;
font-size: 14px;
}

.form-group input, 
.form-group select, 
.form-group textarea {
width: 100%;
padding: 12px 16px;
border: 2px solid #e0e0e0;
border-radius: 10px;
font-size: 16px;
transition: all 0.3s ease;
background: rgba(255, 255, 255, 0.9);
font-family: inherit;
}

.form-group input:focus, 
.form-group select:focus, 
.form-group textarea:focus {
outline: none;
border-color: #4c63d2;
box-shadow: 0 0 0 3px rgba(76, 99, 210, 0.1);
background: rgba(255, 255, 255, 1);
}

.form-group input[type="color"] {
height: 50px;
cursor: pointer;
padding: 5px;
}

.form-group input[type="file"] {
padding: 8px 12px;
cursor: pointer;
}

.form-group textarea {
resize: vertical;
min-height: 100px;
}

.btn {
padding: 12px 20px;
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
color: white;
border: none;
border-radius: 25px;
cursor: pointer;
font-size: 14px;
font-weight: 600;
transition: all 0.3s ease;
margin: 5px;
display: inline-block;
text-decoration: none;
text-align: center;
min-width: 100px;
touch-action: manipulation;
user-select: none;
}

.btn:hover, .btn:active {
transform: translateY(-2px);
box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
filter: brightness(1.1);
}

.btn-danger {
background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
}

.btn-success {
background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
}

.btn-secondary {
background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
}

.participants-grid {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
gap: 15px;
margin-top: 15px;
}

.participant-card {
background: linear-gradient(135deg, #f8f9ff 0%, #e8f0ff 100%);
border-radius: 15px;
padding: 15px;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
transition: all 0.3s ease;
cursor: pointer;
border: 3px solid transparent;
}

.participant-card:hover, .participant-card:active {
transform: translateY(-5px);
box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
border-color: #4c63d2;
}

.participant-name {
font-size: 16px;
font-weight: 600;
color: #4c63d2;
margin-bottom: 10px;
text-align: center;
}

.quick-participants {
background: rgba(255, 255, 255, 0.95);
border-radius: 15px;
padding: 15px;
margin-bottom: 15px;
backdrop-filter: blur(10px);
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.quick-participants h3 {
color: #4c63d2;
margin-bottom: 12px;
text-align: center;
font-size: 16px;
}

.quick-participant-list {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
gap: 8px;
}

.quick-participant-item {
background: linear-gradient(135deg, #f8f9ff 0%, #e8f0ff 100%);
border: 2px solid transparent;
border-radius: 10px;
padding: 10px 6px;
text-align: center;
cursor: pointer;
transition: all 0.3s ease;
font-size: 12px;
font-weight: 600;
color: #4c63d2;
position: relative;
overflow: hidden;
touch-action: manipulation;
min-height: 45px;
display: flex;
align-items: center;
justify-content: center;
}

.quick-participant-item:hover, .quick-participant-item:active {
transform: translateY(-2px);
box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
border-color: #4c63d2;
}

.quick-participant-item.active {
background: linear-gradient(135deg, #4c63d2 0%, #764ba2 100%);
color: white;
transform: translateY(-2px);
box-shadow: 0 5px 15px rgba(76, 99, 210, 0.4);
}

.quick-participant-badge {
position: absolute;
top: -3px;
right: -3px;
background: #ff6b6b;
color: white;
border-radius: 50%;
width: 18px;
height: 18px;
font-size: 10px;
display: flex;
align-items: center;
justify-content: center;
font-weight: bold;
}

.qr-code {
    text-align: center;
    margin: 10px 0;
}

.qr-code div {
    display: inline-block;
    border: 3px solid #4c63d2;
    border-radius: 10px;
    padding: 8px;
    background: white;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.camera-container {
position: relative;
width: 100%;
max-width: 350px;
margin: 15px auto;
text-align: center;
}

#video {
width: 100%;
border-radius: 10px;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
background: #000;
}

.message-form {
background: rgba(76, 99, 210, 0.05);
border-radius: 15px;
padding: 20px;
margin-top: 15px;
border: 2px solid rgba(76, 99, 210, 0.2);
}

.photo-upload-section {
background: rgba(255, 255, 255, 0.9);
border-radius: 10px;
padding: 15px;
margin: 15px 0;
border: 2px dashed #4c63d2;
text-align: center;
}

.photo-preview {
margin-top: 15px;
display: none;
}

.photo-preview img {
max-width: 100%;
max-height: 200px;
border-radius: 10px;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}

.remove-photo {
margin-top: 10px;
background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
color: white;
border: none;
padding: 8px 16px;
border-radius: 20px;
cursor: pointer;
font-size: 12px;
font-weight: 600;
}

.messages-container {
max-height: 300px;
overflow-y: auto;
border: 2px solid #e0e0e0;
border-radius: 10px;
padding: 12px;
margin-top: 10px;
background: rgba(255, 255, 255, 0.5);
}

.message {
background: rgba(76, 99, 210, 0.1);
border-radius: 10px;
padding: 12px;
margin-bottom: 10px;
border-left: 4px solid #4c63d2;
transition: all 0.3s ease;
}

.message:hover {
background: rgba(76, 99, 210, 0.15);
transform: translateX(5px);
}

.message-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 6px;
flex-wrap: wrap;
}

.message-sender {
font-weight: 600;
color: #4c63d2;
font-size: 13px;
}

.message-time {
font-size: 11px;
color: #666;
white-space: nowrap;
}

.message-type {
font-size: 12px;
color: #888;
margin-bottom: 6px;
font-style: italic;
}

.message-content {
color: #333;
line-height: 1.4;
font-size: 13px;
word-wrap: break-word;
}

.message-photo {
margin-top: 10px;
text-align: center;
}

.message-photo img {
max-width: 100%;
max-height: 150px;
border-radius: 8px;
box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
cursor: pointer;
transition: transform 0.3s ease;
}

.message-photo img:hover {
transform: scale(1.05);
}

.photo-modal {
display: none;
position: fixed;
z-index: 2000;
left: 0;
top: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.9);
backdrop-filter: blur(5px);
}

.photo-modal-content {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
max-width: 90%;
max-height: 90%;
}

.photo-modal img {
width: 100%;
height: auto;
border-radius: 10px;
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
}

.photo-modal-close {
position: absolute;
top: 15px;
right: 25px;
color: white;
font-size: 35px;
font-weight: bold;
cursor: pointer;
z-index: 2001;
}

.photo-modal-close:hover {
color: #ccc;
}

.numeric-keypad {
display: grid;
grid-template-columns: repeat(3, 1fr);
gap: 12px;
max-width: 320px;
margin: 15px auto;
padding: 15px;
background: rgba(255, 255, 255, 0.9);
border-radius: 15px;
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

.numeric-key {
aspect-ratio: 1;
border: none;
border-radius: 12px;
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
color: white;
font-size: 22px;
font-weight: 700;
cursor: pointer;
transition: all 0.2s ease;
display: flex;
align-items: center;
justify-content: center;
min-height: 60px;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
user-select: none;
-webkit-user-select: none;
-webkit-tap-highlight-color: transparent;
touch-action: manipulation;
position: relative;
}

.numeric-key:before {
content: '';
position: absolute;
top: 50%;
left: 50%;
width: 0;
height: 0;
background: rgba(255, 255, 255, 0.3);
border-radius: 50%;
transform: translate(-50%, -50%);
transition: all 0.3s ease;
}

.numeric-key:active:before {
width: 80%;
height: 80%;
}

.numeric-key:hover, .numeric-key:active {
transform: translateY(-2px) scale(1.05);
box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
filter: brightness(1.1);
}

.numeric-key.delete {
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
    
    font-size: 14px; /* font mai mic pentru text mai lung */
    font-weight: 600;
}

.numeric-key.zero {
    font-size: 22px; /* font mai mic pentru text mai lung */
    font-weight: 600;
}

.numeric-key.submit {
    background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
    font-size: 14px; /* font mai mic pentru text mai lung */
    font-weight: 600;
}


.password-display {
text-align: center;
margin: 15px 0;
padding: 15px;
background: rgba(255, 255, 255, 0.9);
border-radius: 12px;
border: 3px solid #4c63d2;
font-size: 24px;
letter-spacing: 8px;
font-family: monospace;
min-height: 60px;
display: flex;
align-items: center;
justify-content: center;
font-weight: bold;
color: #4c63d2;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.password-dots {
font-size: 28px;
color: #4c63d2;
letter-spacing: 6px;
}

.keypad-container {
background: rgba(76, 99, 210, 0.05);
border-radius: 20px;
padding: 20px;
margin: 15px 0;
border: 2px solid rgba(76, 99, 210, 0.2);
}

.password-section {
background: rgba(255, 255, 255, 0.9);
border-radius: 15px;
padding: 20px;
margin-bottom: 15px;
text-align: center;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.individual-password-section {
background: rgba(76, 99, 210, 0.1);
border-radius: 15px;
padding: 20px;
margin-bottom: 15px;
text-align: center;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
border: 2px solid rgba(76, 99, 210, 0.2);
}

.success-message {
background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
color: white;
padding: 12px;
border-radius: 10px;
margin-bottom: 15px;
text-align: center;
font-weight: 600;
box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
}

.error-message {
background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
color: white;
padding: 12px;
border-radius: 10px;
margin-bottom: 15px;
text-align: center;
font-weight: 600;
box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3);
}

.message-notification {
position: fixed;
top: 20px;
right: 20px;
padding: 12px 16px;
border-radius: 10px;
color: white;
font-weight: 600;
z-index: 1000;
max-width: 280px;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
font-size: 14px;
}

.checkbox-group {
display: flex;
align-items: center;
gap: 8px;
margin-top: 8px;
}

.checkbox-group input[type="checkbox"] {
width: auto;
margin: 0;
cursor: pointer;
}

.checkbox-group label {
margin: 0;
cursor: pointer;
color: #666;
font-size: 13px;
}

.hidden {
display: none !important;
}

.action-buttons {
display: flex;
gap: 8px;
justify-content: center;
flex-wrap: wrap;
margin-top: 15px;
}

#drawingCanvas {
    border: 2px solid #4c63d2;
    border-radius: 10px;
    touch-action: none;
    margin-bottom: 10px;
    /* Adaugă acestea pentru a permite atingerea */
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

@media (max-width: 768px) {
.container {
    padding: 8px;
}

.header {
    padding: 15px;
    margin-bottom: 15px;
}

.header h1 {
    font-size: 1.8em;
}

.nav-tabs {
    flex-direction: column;
    align-items: center;
    gap: 8px;
    padding: 0 5px;
}

.nav-tab {
    width: 100%;
    max-width: 200px;
    padding: 12px 18px;
    font-size: 14px;
    min-width: unset;
}

.participants-grid {
    grid-template-columns: 1fr;
    gap: 10px;
}

.tab-content {
    padding: 15px;
    margin-bottom: 15px;
}

.tab-content h2 {
    font-size: 1.4em;
    margin-bottom: 15px;
}

.action-buttons {
    flex-direction: column;
    align-items: center;
}

.btn {
    width: 100%;
    max-width: 250px;
    padding: 12px 18px;
    margin: 4px;
    font-size: 15px;
}

.numeric-keypad {
    max-width: 300px;
    gap: 10px;
    padding: 15px;
}

.numeric-key {
    min-height: 55px;
    font-size: 20px;
    border-radius: 10px;
}

.numeric-key.delete,
.numeric-key.submit {
    font-size: 14px;
}

.password-display {
    font-size: 20px;
    letter-spacing: 6px;
    min-height: 55px;
    padding: 12px;
}

.quick-participant-list {
    grid-template-columns: repeat(auto-fit, minmax(85px, 1fr));
    gap: 6px;
}

.quick-participant-item {
    font-size: 11px;
    padding: 8px 4px;
    min-height: 42px;
}

.message-notification {
    top: 10px;
    right: 10px;
    left: 10px;
    max-width: none;
    font-size: 13px;
}

.form-group input, 
.form-group select, 
.form-group textarea {
    font-size: 16px;
    padding: 14px 16px;
}

.photo-modal-content {
    max-width: 95%;
    max-height: 95%;
}

.photo-modal-close {
    top: 10px;
    right: 15px;
    font-size: 28px;
}

.keypad-container {
    padding: 15px;
    margin: 10px 0;
}
}

@media (max-width: 480px) {
.numeric-keypad {
    max-width: 280px;
    gap: 8px;
    padding: 12px;
}

.numeric-key {
    min-height: 50px;
    font-size: 18px;
}

.password-display {
    font-size: 18px;
    letter-spacing: 4px;
    min-height: 50px;
}

.password-dots {
    font-size: 24px;
    letter-spacing: 4px;
}

.nav-tab {
    touch-action: manipulation;
    -webkit-user-select: none;
    user-select: none;
}
}
</style>
</head>
<body>
<div class="container">
<div class="header">
<h1>🏕️ Tabăra 2025</h1>
</div>


<!-- Scanare QR Tab -->
<div id="scan" class="tab-content active">
<div id="qrResult"></div>

<div id="messageForm" class="message-form hidden">
    <h3>Mesaj către <span id="targetName"></span></h3>
    
    <div class="form-group">
        <label for="senderName">Numele tău:</label>
        <input type="text" id="senderName" placeholder="Cum te numești?">
        <div class="checkbox-group">
            <input type="checkbox" id="anonymous">
            <label for="anonymous">Trimite anonim</label>
        </div>
    </div>

    <div class="form-group">
        <label for="messageType">Tipul mesajului:</label>
        <select id="messageType">
            <option value="mesaj">📝 Mesaj simplu</option>
            <option value="compliment">💝 Compliment</option>
            <option value="amintire">🌟 Amintire frumoasă</option>
            <option value="gluma">😂 Glumă</option>
            <option value="incurajare">💪 Încurajare</option>
            <option value="multumire">🙏 Mulțumire</option>
        </select>
    </div>

    <div class="form-group">
        <label for="messageContent">Mesajul tău:</label>
        <textarea id="messageContent" rows="4" placeholder="Scrie aici mesajul tău..."></textarea>
    </div>
    
    <!-- Adaugă acest cod pentru canvas-ul de desen -->
    <div class="form-group">
        <label for="drawingCanvas">Sau desenează mesajul:</label>
        <canvas id="drawingCanvas" width="300" height="200"></canvas>
        <div class="action-buttons">
            <button type="button" id="clearDrawingBtn" class="btn btn-secondary">🗑️ Șterge</button>
        </div>
    </div>
    <!-- Photo Upload Section -->
    <div class="photo-upload-section">
        <label for="photoUpload" style="color: #4c63d2; margin-bottom: 10px; display: block;">
            📸 Adaugă o fotografie (opțional):
        </label>
        <input type="file" id="photoUpload" accept="image/*" capture="environment">
        <p style="font-size: 12px; color: #666; margin-top: 8px;">
            Poți adăuga o fotografie pentru a face mesajul mai special!
        </p>
        
        <div id="photoPreview" class="photo-preview">
            <img id="previewImage" src="" alt="Preview">
            <br>
            <button type="button" id="removePhoto" class="remove-photo">🗑️ Elimină poza</button>
        </div>
    </div>

    <div class="action-buttons">
        <button class="btn" id="sendMessageBtn">📨 Trimite</button>
        <button class="btn" id="sendPhotoOnlyBtn">📸 Doar Poza</button>
        <button class="btn btn-success" id="showParticipantMessagesBtn">📥 Vezi Mesaje</button>
        <button class="btn btn-danger" id="cancelMessageBtn">❌ Anulează</button>
    </div>
</div>
</div>

<!-- Quick Participants List -->
<div id="quickParticipants" class="quick-participants">
    <h3>🎯 Acces Rapid la Participanți</h3>
    <div id="quickParticipantList" class="quick-participant-list">
        <!-- Lista va fi populată dinamic -->
    </div>
</div>
<div class="action-buttons">
    <button class="btn btn-secondary" id="downloadQRCodesBtn">📥 Descarcă Coduri QR</button>
</div>

<!-- Mesaje Participant Individual -->
<div id="participantMessages" class="tab-content">
<h2>Mesaje pentru <span id="participantMessagesName"></span></h2>

<div id="participantPasswordSection" class="individual-password-section">
    <h3>🔐 Acces la mesajele tale</h3>
    
    <div id="passwordStatus" class="password-status hidden">
        Acest participant are deja o parolă setată
    </div>
    
    <div id="setPasswordForm" class="hidden">
        <p style="margin-bottom: 15px; color: #4c63d2; font-weight: 600;">
            Prima dată când accesezi contul, setează o parolă de 4 cifre:
        </p>
        
        <div class="keypad-container">
            <div class="password-display">
                <span id="newPasswordDisplay" class="password-dots"></span>
            </div>
            
            <div class="numeric-keypad">
                <button class="numeric-key" data-key="1" data-keypad="new">1</button>
                <button class="numeric-key" data-key="2" data-keypad="new">2</button>
                <button class="numeric-key" data-key="3" data-keypad="new">3</button>
                <button class="numeric-key" data-key="4" data-keypad="new">4</button>
                <button class="numeric-key" data-key="5" data-keypad="new">5</button>
                <button class="numeric-key" data-key="6" data-keypad="new">6</button>
                <button class="numeric-key" data-key="7" data-keypad="new">7</button>
                <button class="numeric-key" data-key="8" data-keypad="new">8</button>
                <button class="numeric-key" data-key="9" data-keypad="new">9</button>
                <button class="numeric-key delete" data-key="delete" data-keypad="new">🔙 Șterge</button>
                <button class="numeric-key zero" data-key="0" data-keypad="new">0</button>
            </div>
            
            <p style="color: #4c63d2; font-weight: 600; margin: 10px 0;">Confirmă parola:</p>
            
            <div class="password-display">
                <span id="confirmPasswordDisplay" class="password-dots"></span>
            </div>
            
            <div class="numeric-keypad">
                <button class="numeric-key" data-key="1" data-keypad="confirm">1</button>
                <button class="numeric-key" data-key="2" data-keypad="confirm">2</button>
                <button class="numeric-key" data-key="3" data-keypad="confirm">3</button>
                <button class="numeric-key" data-key="4" data-keypad="confirm">4</button>
                <button class="numeric-key" data-key="5" data-keypad="confirm">5</button>
                <button class="numeric-key" data-key="6" data-keypad="confirm">6</button>
                <button class="numeric-key" data-key="7" data-keypad="confirm">7</button>
                <button class="numeric-key" data-key="8" data-keypad="confirm">8</button>
                <button class="numeric-key" data-key="9" data-keypad="confirm">9</button>
                <button class="numeric-key delete" data-key="delete" data-keypad="confirm">🔙 Șterge</button>
                <button class="numeric-key zero" data-key="0" data-keypad="confirm">0</button>
                <button class="numeric-key submit" data-key="submit" data-keypad="confirm" id="setParticipantPasswordBtn">🔒 Setează</button>
            </div>
        </div>
    </div>
    
    <div id="enterPasswordForm" class="hidden">
        <div class="keypad-container">
            <div class="password-display">
                <span id="enterPasswordDisplay" class="password-dots"></span>
            </div>
            
            <div class="numeric-keypad">
                <button class="numeric-key" data-key="1" data-keypad="enter">1</button>
                <button class="numeric-key" data-key="2" data-keypad="enter">2</button>
                <button class="numeric-key" data-key="3" data-keypad="enter">3</button>
                <button class="numeric-key" data-key="4" data-keypad="enter">4</button>
                <button class="numeric-key" data-key="5" data-keypad="enter">5</button>
                <button class="numeric-key" data-key="6" data-keypad="enter">6</button>
                <button class="numeric-key" data-key="7" data-keypad="enter">7</button>
                <button class="numeric-key" data-key="8" data-keypad="enter">8</button>
                <button class="numeric-key" data-key="9" data-keypad="enter">9</button>
                <button class="numeric-key delete" data-key="delete" data-keypad="enter">🔙 Șterge</button>
                <button class="numeric-key zero" data-key="0" data-keypad="enter">0</button>
                <button class="numeric-key submit" data-key="submit" data-keypad="enter" id="checkParticipantPasswordBtn">🔓 Verifică</button>
            </div>
            
        </div>
    </div>
    
    <div id="participantPasswordError" class="error-message hidden"></div>
</div>

<div id="participantMessagesList" class="hidden">
    <!-- Mesajele participantului vor fi afișate aici -->
</div>

<div class="action-buttons">
    <button class="btn" id="backToScanBtn">❌ Înapoi</button>
</div>
</div>
</div>

<!-- Photo Modal -->
<div id="photoModal" class="photo-modal">
<span class="photo-modal-close">&times;</span>
<div class="photo-modal-content">
<img id="modalImage" src="" alt="Photo">
</div>
</div>

<!-- Firebase SDK -->
<script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getStorage, ref, uploadBytes, getDownloadURL } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';
    import { getFirestore, collection, addDoc, serverTimestamp, getDocs, query, orderBy, doc, updateDoc, where } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
    
    // Configurația Firebase
    const firebaseConfig = {
    apiKey: "AIzaSyAA1ytLJrwh7JHSOwGQrf2t_5imgtiWLk4",
    authDomain: "tabara-2025-95ff5.firebaseapp.com",
    projectId: "tabara-2025-95ff5",
    storageBucket: "tabara-2025-95ff5.firebasestorage.app",
    messagingSenderId: "552618851743",
    appId: "1:552618851743:web:tabara2025app"
    };
    
    // Inițializează Firebase
    const app = initializeApp(firebaseConfig);
    const storage = getStorage(app);
    const db = getFirestore(app);
    
    // Funcție pentru încărcarea pozei în Firebase Storage
    async function uploadImageToFirebase(file, objectName) {
    try {
        const timestamp = Date.now();
        const fileName = `mesaje-tabara/${objectName}_${timestamp}.jpg`;
        const storageRef = ref(storage, fileName);
        const snapshot = await uploadBytes(storageRef, file);
        const downloadURL = await getDownloadURL(snapshot.ref);
        return downloadURL;
    } catch (error) {
        console.error("Eroare la încărcarea pozei:", error);
        throw error;
    }
    }
    
    // Funcție pentru hash-ul parolei
    function hashPassword(password) {
        let hash = 0;
        const salt = "tabara2025_salt_";
        const input = salt + password;
        
        for (let i = 0; i < input.length; i++) {
            const char = input.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash).toString(36);
    }
    
    // Funcție pentru verificarea parolei
    function verifyPassword(inputPassword, storedHash) {
        return hashPassword(inputPassword) === storedHash;
    }
    
    // Funcție pentru salvarea parolei în Firebase
    async function saveParticipantPasswordToFirebase(participantId, hashedPassword) {
        try {
            const q = query(collection(db, "participants"), where("localId", "==", participantId));
            const querySnapshot = await getDocs(q);
            
            if (!querySnapshot.empty) {
                const docRef = querySnapshot.docs[0].ref;
                await updateDoc(docRef, {
                    hasPassword: true,
                    passwordHash: hashedPassword,
                    passwordUpdatedAt: serverTimestamp()
                });
                return true;
            }
            return false;
        } catch (error) {
            console.error("Eroare la salvarea parolei în Firebase:", error);
            throw error;
        }
    }
    
    // Funcție pentru resetarea parolei în Firebase
    async function resetParticipantPasswordInFirebase(participantId) {
        try {
            const q = query(collection(db, "participants"), where("localId", "==", participantId));
            const querySnapshot = await getDocs(q);
            
            if (!querySnapshot.empty) {
                const docRef = querySnapshot.docs[0].ref;
                await updateDoc(docRef, {
                    hasPassword: false,
                    passwordHash: null,
                    passwordUpdatedAt: serverTimestamp()
                });
                return true;
            }
            return false;
        } catch (error) {
            console.error("Eroare la resetarea parolei în Firebase:", error);
            throw error;
        }
    }
    
    // Funcție pentru încărcarea parolelor din Firebase
    async function loadParticipantPasswordsFromFirebase() {
        try {
            const q = query(collection(db, "participants"), orderBy("createdAt", "asc"));
            const querySnapshot = await getDocs(q);
            const passwordData = {};
            
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                if (data.localId && data.hasPassword) {
                    passwordData[data.localId] = {
                        hasPassword: data.hasPassword,
                        passwordHash: data.passwordHash || null
                    };
                }
            });
            
            return passwordData;
        } catch (error) {
            console.error("Eroare la încărcarea parolelor din Firebase:", error);
            return {};
        }
    }
    
    // Funcție pentru încărcarea participanților din Firebase
    async function loadParticipantsFromFirebase() {
        try {
            const q = query(collection(db, "participants"), orderBy("createdAt", "asc"));
            const querySnapshot = await getDocs(q);
            const firebaseParticipants = [];
            
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                firebaseParticipants.push({
                    id: data.localId || data.createdAt?.toMillis() || Date.now(),
                    name: data.name,
                    nickname: data.nickname || '',
                    color: data.color,
                    hasPassword: data.hasPassword || false,
                    password: null
                });
            });
            
            return firebaseParticipants;
        } catch (error) {
            console.error("Eroare la încărcarea participanților:", error);
            return [];
        }
    }
    
    // Funcție modificată pentru încărcarea participanților cu parole din Firebase
    async function loadParticipantsFromFirebaseWithPasswords() {
        try {
            const [participantsData, passwordData] = await Promise.all([
                loadParticipantsFromFirebase(),
                loadParticipantPasswordsFromFirebase()
            ]);
            
            // Combină datele participanților cu parolele
            const participantsWithPasswords = participantsData.map(participant => {
                const passwordInfo = passwordData[participant.id];
                return {
                    ...participant,
                    hasPassword: passwordInfo ? passwordInfo.hasPassword : false,
                    passwordHash: passwordInfo ? passwordInfo.passwordHash : null,
                    password: null // Nu salvăm parola în text clar
                };
            });
            
            return participantsWithPasswords;
        } catch (error) {
            console.error("Eroare la încărcarea participanților cu parole:", error);
            return await loadParticipantsFromFirebase(); // Fallback la versiunea fără parole
        }
    }
    
    // Funcție pentru încărcarea mesajelor din Firebase
    async function loadMessagesFromFirebase() {
        try {
            const q = query(collection(db, "messages"), orderBy("createdAt", "asc"));
            const querySnapshot = await getDocs(q);
            const firebaseMessages = [];
            
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                firebaseMessages.push({
                    id: data.localMessageId || data.createdAt || Date.now(),
                    recipientId: data.recipientId,
                    sender: data.sender,
                    type: data.type,
                    content: data.content,
                    photo: data.photo,
                    timestamp: data.createdAt || new Date().toISOString()
                });
            });
            
            return firebaseMessages;
        } catch (error) {
            console.error("Eroare la încărcarea mesajelor:", error);
            return [];
        }
    }
    
    // Funcție modificată pentru sincronizarea automată cu parole
    async function autoSyncWithPasswords() {
        if (!window.firebaseInitialized) return;
        
        try {
            const firebaseParticipants = await loadParticipantsFromFirebaseWithPasswords();
            const firebaseMessages = await loadMessagesFromFirebase();
            
            let updated = false;
            
            // Verifică dacă participanții sau parolele au fost actualizate
            if (firebaseParticipants.length >= participants.length) {
                const hasPasswordUpdates = firebaseParticipants.some(fbParticipant => {
                    const localParticipant = participants.find(p => p.id === fbParticipant.id);
                    return !localParticipant || 
                           localParticipant.hasPassword !== fbParticipant.hasPassword ||
                           localParticipant.passwordHash !== fbParticipant.passwordHash;
                });
                
                if (firebaseParticipants.length > participants.length || hasPasswordUpdates) {
                    participants = firebaseParticipants;
                    localStorage.setItem('participants', JSON.stringify(participants));
                    loadParticipants();
                    loadQuickParticipants();
                    updated = true;
                }
            }
            
            if (firebaseMessages.length > messages.length) {
                messages = firebaseMessages;
                localStorage.setItem('messages', JSON.stringify(messages));
                updateParticipantMessages();
                if (isLoggedIn) displayAllMessages();
                updated = true;
            }
            
            if (updated) {
                console.log('Date sincronizate automat din cloud (inclusiv parole)');
            }
        } catch (error) {
            console.error('Eroare la sincronizarea automată:', error);
        }
    }
    
    // Funcție pentru salvarea participanților în Firebase
    async function saveParticipantToFirebase(participant) {
    try {
        const docRef = await addDoc(collection(db, "participants"), {
            name: participant.name,
            nickname: participant.nickname || '',
            color: participant.color,
            hasPassword: participant.hasPassword,
            createdAt: serverTimestamp(),
            localId: participant.id
        });
        return docRef.id;
    } catch (error) {
        console.error("Eroare la salvarea participantului:", error);
        throw error;
    }
    }
    
    // Funcție pentru salvarea mesajelor în Firebase
    async function saveMessageToFirebase(message, recipientName) {
    try {
        const docRef = await addDoc(collection(db, "messages"), {
            recipientId: message.recipientId,
            recipientName: recipientName,
            sender: message.sender,
            type: message.type,
            content: message.content,
            photo: message.photo || null,
            timestamp: serverTimestamp(),
            createdAt: new Date().toISOString(),
            localMessageId: message.id
        });
        return docRef.id;
    } catch (error) {
        console.error("Eroare la salvarea mesajului:", error);
        throw error;
    }
    }
    
    // Fă funcțiile disponibile global
    window.uploadImageToFirebase = uploadImageToFirebase;
    window.hashPassword = hashPassword;
    window.verifyPassword = verifyPassword;
    window.saveParticipantPasswordToFirebase = saveParticipantPasswordToFirebase;
    window.resetParticipantPasswordInFirebase = resetParticipantPasswordInFirebase;
    window.loadParticipantPasswordsFromFirebase = loadParticipantPasswordsFromFirebase;
    window.loadParticipantsFromFirebase = loadParticipantsFromFirebase;
    window.loadParticipantsFromFirebaseWithPasswords = loadParticipantsFromFirebaseWithPasswords;
    window.loadMessagesFromFirebase = loadMessagesFromFirebase;
    window.saveParticipantToFirebase = saveParticipantToFirebase;
    window.saveMessageToFirebase = saveMessageToFirebase;
    window.autoSyncWithPasswords = autoSyncWithPasswords;
    window.showPasswordSetupStep1 = showPasswordSetupStep1;
    window.showPasswordSetupStep2 = showPasswordSetupStep2;
    window.hideAllPasswordForms = hideAllPasswordForms;
    window.handleKeypadInputModified = handleKeypadInput;
    window.setupNumericKeypadModified = setupNumericKeypad;
    window.showParticipantMessages = showParticipantMessages;
    window.firebaseInitialized = true;
    </script>
    
    <script>
    // ==================== GLOBAL VARIABLES ====================
    let participants = [];
    let messages = [];
    let password = localStorage.getItem('password');
    let isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
    let currentRecipient = null;
    let videoStream = null;
    let scanning = false;
    let currentPhotoData = null;
    
    // Password input states for numeric keypad
    let adminPasswordInput = '';
    let newPasswordInput = '';
    let confirmPasswordInput = '';
    let enterPasswordInput = '';
    
    // ==================== UTILITY FUNCTIONS ====================
    function showMessage(message, type = 'info') {
    const existingNotifications = document.querySelectorAll('.message-notification');
    existingNotifications.forEach(notif => notif.remove());
    
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message-notification';
    messageDiv.textContent = message;
    
    const colors = {
        'success': 'linear-gradient(135deg, #4caf50 0%, #45a049 100%)',
        'error': 'linear-gradient(135deg, #f44336 0%, #d32f2f 100%)',
        'info': 'linear-gradient(135deg, #2196f3 0%, #1976d2 100%)'
    };
    
    messageDiv.style.background = colors[type] || colors.info;
    messageDiv.style.position = 'fixed';
    messageDiv.style.top = '20px';
    messageDiv.style.right = '20px';
    messageDiv.style.padding = '12px 16px';
    messageDiv.style.borderRadius = '10px';
    messageDiv.style.color = 'white';
    messageDiv.style.fontWeight = '600';
    messageDiv.style.zIndex = '1000';
    messageDiv.style.maxWidth = '280px';
    messageDiv.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.2)';
    messageDiv.style.fontSize = '14px';
    
    document.body.appendChild(messageDiv);
    
    setTimeout(() => {
        if (messageDiv.parentNode) {
            messageDiv.remove();
        }
    }, 3000);
    }
    
    function sanitizeInput(input) {
    const div = document.createElement('div');
    div.textContent = input;
    return div.innerHTML;
    }
    
    function hashCode(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return Math.abs(hash);
    }
    
    function getMessageTypeIcon(type) {
    const icons = {
        'mesaj': '📝',
        'compliment': '💝',
        'amintire': '🌟',
        'gluma': '😂',
        'incurajare': '💪',
        'multumire': '🙏',
        'foto': '📸'
    };
    return icons[type] || '📝';
    }
    
    function getMessageTypeName(type) {
    const names = {
        'mesaj': 'Mesaj simplu',
        'compliment': 'Compliment',
        'amintire': 'Amintire frumoasă',
        'gluma': 'Glumă',
        'incurajare': 'Încurajare',
        'multumire': 'Mulțumire',
        'foto': 'Doar fotografie'
    };
    return names[type] || 'Mesaj';
    }
    
    // ==================== PHOTO FUNCTIONS ====================
    function setupPhotoUpload() {
    const photoUpload = document.getElementById('photoUpload');
    const photoPreview = document.getElementById('photoPreview');
    const previewImage = document.getElementById('previewImage');
    const removePhoto = document.getElementById('removePhoto');
    
    if (photoUpload) {
        photoUpload.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                if (file.size > 5 * 1024 * 1024) {
                    showMessage('Poza este prea mare! Maxim 5MB.', 'error');
                    return;
                }
    
                if (!file.type.startsWith('image/')) {
                    showMessage('Te rog selectează doar imagini!', 'error');
                    return;
                }
    
                const reader = new FileReader();
                reader.onload = function(e) {
                    currentPhotoData = e.target.result;
                    previewImage.src = currentPhotoData;
                    photoPreview.style.display = 'block';
                    showMessage('Poza a fost adăugată cu succes!', 'success');
                };
                reader.readAsDataURL(file);
            }
        });
    }
    
    if (removePhoto) {
        removePhoto.addEventListener('click', function() {
            currentPhotoData = null;
            photoPreview.style.display = 'none';
            previewImage.src = '';
            photoUpload.value = '';
            showMessage('Poza a fost eliminată!', 'info');
        });
    }
    }
    
    function setupPhotoModal() {
    const modal = document.getElementById('photoModal');
    const closeBtn = document.querySelector('.photo-modal-close');
    
    if (closeBtn) {
        closeBtn.addEventListener('click', function() {
            modal.style.display = 'none';
        });
    }
    
    if (modal) {
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                modal.style.display = 'none';
            }
        });
    }
    
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && modal.style.display === 'block') {
            modal.style.display = 'none';
        }
    });
    }
    
    function openPhotoModal(imageSrc) {
    const modal = document.getElementById('photoModal');
    const modalImage = document.getElementById('modalImage');
    
    if (modal && modalImage) {
        modalImage.src = imageSrc;
        modal.style.display = 'block';
    }
    }
    
    function clearPhotoData() {
    currentPhotoData = null;
    const photoPreview = document.getElementById('photoPreview');
    const previewImage = document.getElementById('previewImage');
    const photoUpload = document.getElementById('photoUpload');
    
    if (photoPreview) photoPreview.style.display = 'none';
    if (previewImage) previewImage.src = '';
    if (photoUpload) photoUpload.value = '';
    }
    
    async function base64ToFile(base64, filename = 'photo.jpg') {
    const response = await fetch(base64);
    const blob = await response.blob();
    return new File([blob], filename, { type: blob.type });
    }
    
    // ==================== TAB MANAGEMENT ====================
    function showTab(tabName) {
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelectorAll('.nav-tab').forEach(btn => {
        btn.classList.remove('active');
    });
    
    const targetTab = document.getElementById(tabName);
    const targetButton = document.querySelector(`[data-tab="${tabName}"]`);
    
    if (targetTab) targetTab.classList.add('active');
    if (targetButton) targetButton.classList.add('active');
    
    switch (tabName) {
        case 'admin':
            loadParticipants();
            break;
        case 'scan':
            loadQuickParticipants();
            break;
        case 'messages':
            checkMessagesAccess();
            break;
        case 'participantMessages':
            checkParticipantAccess();
            break;
    }
    }
    
    // ==================== NUMERIC KEYPAD FUNCTIONS ====================
    function updatePasswordDisplay(keypadType, password) {
    const displays = {
        'admin': 'adminPasswordDisplay',
        'new': 'newPasswordDisplay', 
        'confirm': 'confirmPasswordDisplay',
        'enter': 'enterPasswordDisplay'
    };
    
    const displayId = displays[keypadType];
    const display = document.getElementById(displayId);
    
    if (display) {
        display.textContent = '●'.repeat(password.length);
    }
    }
    
    // Modifică funcția handleKeypadInput pentru a gestiona tranziția între pași
function handleKeypadInput(keypadType, key) {
    const maxLengths = {
        'admin': 6,
        'new': 4,
        'confirm': 4, 
        'enter': 4
    };

    const maxLength = maxLengths[keypadType];

    if (key === 'delete') {
        switch(keypadType) {
            case 'admin':
                adminPasswordInput = adminPasswordInput.slice(0, -1);
                break;
            case 'new':
                newPasswordInput = newPasswordInput.slice(0, -1);
                break;
            case 'confirm':
                confirmPasswordInput = confirmPasswordInput.slice(0, -1);
                break;
            case 'enter':
                enterPasswordInput = enterPasswordInput.slice(0, -1);
                break;
        }
    } else if (key === 'submit') {
        if (keypadType === 'admin') {
            checkAdminPasswordFromKeypad();
        } else if (keypadType === 'new') {
            // Pentru step 1 - treci la confirmarea parolei
            showPasswordSetupStep2();
        } else if (keypadType === 'confirm') {
            // Pentru step 2 - setează parola final
            setParticipantPassword();
        } else if (keypadType === 'enter') {
            checkParticipantPassword();
        }
        return;
    } else if (key >= '0' && key <= '9') {
        switch(keypadType) {
            case 'admin':
                if (adminPasswordInput.length < maxLength) {
                    adminPasswordInput += key;
                }
                break;
            case 'new':
                if (newPasswordInput.length < maxLength) {
                    newPasswordInput += key;
                }
                break;
            case 'confirm':
                if (confirmPasswordInput.length < maxLength) {
                    confirmPasswordInput += key;
                }
                break;
            case 'enter':
                if (enterPasswordInput.length < maxLength) {
                    enterPasswordInput += key;
                }
                break;
        }
    }

    const passwords = {
        'admin': adminPasswordInput,
        'new': newPasswordInput,
        'confirm': confirmPasswordInput,
        'enter': enterPasswordInput
    };

    updatePasswordDisplay(keypadType, passwords[keypadType]);

    if (navigator.vibrate) {
        navigator.vibrate(50);
    }
}


  // Actualizează funcția setupNumericKeypad pentru a folosi noua funcție
function setupNumericKeypad() {
    document.querySelectorAll('.numeric-key').forEach(key => {
        function handleKeyAction(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const keyValue = key.getAttribute('data-key');
            const keypadType = key.getAttribute('data-keypad') || 'admin';
            
            handleKeypadInputModified(keypadType, keyValue);
        }
        
        key.addEventListener('touchstart', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            this.style.transform = 'translateY(-4px) scale(1.05)';
            this.style.filter = 'brightness(1.2)';
            
            handleKeyAction(e);
            
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
        });
        
        key.addEventListener('touchend', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            setTimeout(() => {
                this.style.transform = '';
                this.style.filter = '';
            }, 150);
        });
        
        key.addEventListener('click', function(e) {
            if (e.detail !== 0) {
                handleKeyAction(e);
            }
        });
        
        key.addEventListener('mousedown', function(e) {
            e.preventDefault();
            this.style.transform = 'translateY(-4px) scale(1.05)';
            this.style.filter = 'brightness(1.2)';
        });
        
        key.addEventListener('mouseup', function(e) {
            e.preventDefault();
            setTimeout(() => {
                this.style.transform = '';
                this.style.filter = '';
            }, 150);
        });
        
        key.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });
    });
}
    // ==================== PARTICIPANT MANAGEMENT ====================
    async function addParticipant() {
    const nameInput = document.getElementById('participantName');
    const nicknameInput = document.getElementById('participantNickname');
    const colorInput = document.getElementById('participantColor');
    
    if (!nameInput || !colorInput) {
        showMessage('Elementele formularului nu sunt disponibile!', 'error');
        return;
    }
    
    const name = nameInput.value.trim();
    const nickname = nicknameInput ? nicknameInput.value.trim() : '';
    const color = colorInput.value;
    
    if (!name) {
        showMessage('Numele este obligatoriu!', 'error');
        return;
    }
    
    const participant = {
        id: Date.now(),
        name: sanitizeInput(name),
        nickname: sanitizeInput(nickname),
        color: color,
        password: null,
        hasPassword: false,
        passwordHash: null,
        messages: []
    };
    
    participants.push(participant);
    localStorage.setItem('participants', JSON.stringify(participants));
    
    if (window.firebaseInitialized && window.saveParticipantToFirebase) {
        try {
            await window.saveParticipantToFirebase(participant);
            showMessage('Participantul a fost adăugat local și în cloud!', 'success');
        } catch (error) {
            console.error('Eroare la salvarea în Firebase:', error);
            showMessage('Participantul a fost adăugat local. Eroare cloud: ' + error.message, 'success');
        }
    } else {
        showMessage('Participantul a fost adăugat local!', 'success');
    }
    
    nameInput.value = '';
    if (nicknameInput) nicknameInput.value = '';
    colorInput.value = '#4c63d2';
    
    loadParticipants();
    loadQuickParticipants();
    }
    
    function deleteParticipant(participantId) {
    if (!confirm('Sigur doriți să ștergeți acest participant și toate mesajele lui?')) {
        return;
    }
    
    participants = participants.filter(p => p.id !== participantId);
    messages = messages.filter(m => m.recipientId !== participantId);
    
    localStorage.setItem('participants', JSON.stringify(participants));
    localStorage.setItem('messages', JSON.stringify(messages));
    
    loadParticipants();
    loadQuickParticipants();
    showMessage('Participantul a fost șters cu succes!', 'success');
    }
    
    function clearAllData() {
    if (!confirm('ATENȚIE: Această acțiune va șterge toți participanții și toate mesajele! Sigur doriți să continuați?')) {
        return;
    }
    
    participants = [];
    messages = [];
    password = null;
    isLoggedIn = false;
    currentRecipient = null;
    
    adminPasswordInput = '';
    newPasswordInput = '';
    confirmPasswordInput = '';
    enterPasswordInput = '';
    
    localStorage.clear();
    
    loadParticipants();
    loadQuickParticipants();
    showMessage('Toate datele au fost șterse cu succes!', 'success');
    
    const passwordSection = document.getElementById('passwordSection');
    const messagesList = document.getElementById('messagesList');
    
    if (passwordSection) passwordSection.classList.remove('hidden');
    if (messagesList) messagesList.classList.add('hidden');
    }
    
    function loadParticipants() {
    const container = document.getElementById('participantsContainer');
    if (!container) return;
    
    container.innerHTML = '';
    if (participants.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">Nu există participanți adăugați.</p>';
        return;
    }
    
    participants.forEach(participant => {
        const card = createParticipantCard(participant);
        container.appendChild(card);
    });
    }
    
    function createParticipantCard(participant) {
const card = document.createElement('div');
card.className = 'participant-card';
card.style.borderLeft = `5px solid ${participant.color}`;

const displayName = participant.nickname ? 
    `${participant.name} (${participant.nickname})` : 
    participant.name;

const participantMessages = messages.filter(m => m.recipientId === participant.id);
const messageCount = participantMessages.length;
const passwordStatusIcon = participant.hasPassword ? '🔒' : '🔓';
const passwordStatusText = participant.hasPassword ? 'Parolă setată' : 'Fără parolă';

card.innerHTML = `
    <div class="participant-name">${displayName}</div>
    <div style="text-align: center; margin-bottom: 10px; color: #666; font-size: 12px;">
        ${passwordStatusIcon} ${passwordStatusText}
    </div>
    <div class="qr-code">
        <div class="qr-code">
    <div id="qr-${participant.id}"></div>
</div>
    </div>
    <div style="text-align: center; margin: 10px 0;">
        <button class="btn btn-danger" onclick="deleteParticipant(${participant.id})">🗑️ Șterge</button>
    </div>
    <div class="messages-container">
        <strong>Mesaje primite (${messageCount}):</strong>
        <div id="messages-${participant.id}">
            ${participantMessages.length > 0 ? 
                participantMessages.slice(0, 3).map(msg => `
                    <div class="message">
                        <div class="message-header">
                            <span class="message-sender">${getMessageTypeIcon(msg.type)} ${msg.sender}</span>
                            <span class="message-time">${new Date(msg.timestamp).toLocaleString('ro-RO')}</span>
                        </div>
                        <div class="message-type">${getMessageTypeName(msg.type)}</div>
                        <div class="message-content">${msg.content || 'Fără text'}</div>
                        ${msg.photo ? `
                            <div class="message-photo">
                                <img src="${msg.photo}" alt="Photo" onclick="openPhotoModal('${msg.photo}')" style="max-width: 100px; max-height: 80px;">
                            </div>
                        ` : ''}
                    </div>
                `).join('') + (participantMessages.length > 3 ? '<p style="color: #666; font-style: italic; text-align: center;">... și alte mesaje</p>' : '') : 
                '<p style="color: #666; font-style: italic;">Nu există mesaje</p>'
            }
        </div>
    </div>
`;

card.addEventListener('click', () => {
    currentRecipient = participant;
    const targetName = document.getElementById('targetName');
    const participantMessagesName = document.getElementById('participantMessagesName');
    
    if (targetName) targetName.textContent = participant.name;
    if (participantMessagesName) participantMessagesName.textContent = participant.name;
    
    showTab('scan');
    
    const messageForm = document.getElementById('messageForm');
    if (messageForm) messageForm.classList.remove('hidden');
});

setTimeout(() => {
    generateQRCode(participant.id, displayName);
}, 100);

return card;
}

    
    function generateQRCode(participantId, name) {
    const qrCodeDiv = document.getElementById(`qr-${participantId}`);
    if (!qrCodeDiv) return;
    
    qrCodeDiv.innerHTML = ''; // Șterge conținutul anterior
    
    const url = `${window.location.origin}${window.location.pathname}?tab=scan&participantId=${participantId}`;
    
    new QRCode(qrCodeDiv, {
        text: url,
        width: 120,
        height: 120,
        colorDark: "#000000",
        colorLight: "#ffffff",
        correctLevel: QRCode.CorrectLevel.H
    });
}  

async function downloadQRCodes() {
    const doc = new jspdf.jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 10;
    const qrSize = 50;
    const maxQRsPerPage = Math.floor((pageWidth - 2 * margin) / (qrSize + margin)) * Math.floor((pageHeight - 2 * margin) / (qrSize + margin));

    let currentPage = 1;
    let qrCount = 0;

    for (const participant of participants) {
        if (qrCount >= maxQRsPerPage) {
            doc.addPage();
            currentPage++;
            qrCount = 0;
        }

        const x = margin + (qrCount % Math.floor((pageWidth - 2 * margin) / (qrSize + margin))) * (qrSize + margin);
        const y = margin + Math.floor(qrCount / Math.floor((pageWidth - 2 * margin) / (qrSize + margin))) * (qrSize + margin);

        const qrCodeDataUrl = await generateQRCodeDataUrl(participant.id);
        doc.addImage(qrCodeDataUrl, 'PNG', x, y, qrSize, qrSize);
        doc.text(participant.name, x, y + qrSize + 5);

        qrCount++;
    }

    doc.save('qr_codes.pdf');
}

async function generateQRCodeDataUrl(participantId) {
    return new Promise((resolve) => {
        const qrCodeDiv = document.createElement('div');
        const url = `${window.location.origin}${window.location.pathname}?tab=scan&participantId=${participantId}`;

        new QRCode(qrCodeDiv, {
            text: url,
            width: 500,
            height: 500,
            colorDark: "#000000",
            colorLight: "#ffffff",
            correctLevel: QRCode.CorrectLevel.H
        });

        setTimeout(() => {
            const qrCodeImage = qrCodeDiv.querySelector('img');
            resolve(qrCodeImage.src);
        }, 100);
    });
}

    function loadQuickParticipants() {
    const container = document.getElementById('quickParticipantList');
    if (!container) return;
    
    container.innerHTML = '';
    
    if (participants.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #666; grid-column: 1/-1;">Nu există participanți adăugați.</p>';
        return;
    }
    
    participants.forEach(participant => {
        const item = document.createElement('div');
        item.className = 'quick-participant-item';
        
        const displayName = participant.nickname ? participant.name : participant.name;
        const messageCount = messages.filter(m => m.recipientId === participant.id).length;
        
        item.innerHTML = `
            ${displayName}
            ${messageCount > 0 ? `<div class="quick-participant-badge">${messageCount}</div>` : ''}
        `;
        
        item.style.borderLeftColor = participant.color;
        
        item.addEventListener('click', () => {
            document.querySelectorAll('.quick-participant-item').forEach(i => {
                i.classList.remove('active');
            });
            
            item.classList.add('active');
            
            currentRecipient = participant;
            const targetName = document.getElementById('targetName');
            const participantMessagesName = document.getElementById('participantMessagesName');
            
            if (targetName) targetName.textContent = participant.name;
            if (participantMessagesName) participantMessagesName.textContent = participant.name;
            
            const messageForm = document.getElementById('messageForm');
            if (messageForm) messageForm.classList.remove('hidden');
            
            showMessage(`Participant selectat: ${participant.name}`, 'success');
            
            if (navigator.vibrate) {
                navigator.vibrate([50, 50, 50]);
            }
        });
        
        container.appendChild(item);
    });
    }
    
    // ==================== PASSWORD MANAGEMENT ====================
    function checkAdminPasswordFromKeypad() {
    const errorDiv = document.getElementById('passwordError');
    
    if (!password) {
        if (adminPasswordInput.length !== 6 || !/^\d{6}$/.test(adminPasswordInput)) {
            if (errorDiv) {
                errorDiv.textContent = 'Parola trebuie să fie de 6 cifre!';
                errorDiv.classList.remove('hidden');
            }
            return;
        }
        password = adminPasswordInput;
        localStorage.setItem('password', password);
        localStorage.setItem('isLoggedIn', 'true');
        isLoggedIn = true;
    } else if (adminPasswordInput !== password) {
        if (errorDiv) {
            errorDiv.textContent = 'Parola admin incorectă!';
            errorDiv.classList.remove('hidden');
        }
        return;
    }
    
    const passwordSection = document.getElementById('passwordSection');
    const messagesList = document.getElementById('messagesList');
    
    if (passwordSection) passwordSection.classList.add('hidden');
    if (messagesList) messagesList.classList.remove('hidden');
    
    if (errorDiv) errorDiv.classList.add('hidden');
    
    isLoggedIn = true;
    localStorage.setItem('isLoggedIn', 'true');
    
    displayAllMessages();
    showMessage('Acces admin acordat!', 'success');
    
    adminPasswordInput = '';
    updatePasswordDisplay('admin', '');
    }
    
    async function setParticipantPassword() {
        const errorDiv = document.getElementById('participantPasswordError');
    
        if (!currentRecipient) {
            showMessage('Eroare la setarea parolei!', 'error');
            return;
        }
    
        if (newPasswordInput.length !== 4 || !/^\d{4}$/.test(newPasswordInput)) {
            if (errorDiv) {
                errorDiv.textContent = 'Parola trebuie să fie de exact 4 cifre!';
                errorDiv.classList.remove('hidden');
            }
            return;
        }
    
        if (newPasswordInput !== confirmPasswordInput) {
            if (errorDiv) {
                errorDiv.textContent = 'Parolele nu se potrivesc!';
                errorDiv.classList.remove('hidden');
            }
            return;
        }
    
        try {
            // Hash-uiește parola
            const hashedPassword = window.hashPassword(newPasswordInput);
            
            // Actualizează local
            const participantIndex = participants.findIndex(p => p.id === currentRecipient.id);
            if (participantIndex !== -1) {
                participants[participantIndex].hasPassword = true;
                participants[participantIndex].passwordHash = hashedPassword;
                participants[participantIndex].password = null; // Nu mai salvăm parola în text clar
                currentRecipient = participants[participantIndex];
                
                localStorage.setItem('participants', JSON.stringify(participants));
            }
    
            // Salvează în Firebase
            if (window.firebaseInitialized && window.saveParticipantPasswordToFirebase) {
                showMessage('Salvăm parola în cloud...', 'info');
                await window.saveParticipantPasswordToFirebase(currentRecipient.id, hashedPassword);
                showMessage('Parola a fost setată și salvată în cloud!', 'success');
            } else {
                showMessage('Parola a fost setată local!', 'success');
            }
    
            hidePasswordForms();
            showParticipantMessagesList();
            
            if (errorDiv) errorDiv.classList.add('hidden');
            
            newPasswordInput = '';
            confirmPasswordInput = '';
            updatePasswordDisplay('new', '');
            updatePasswordDisplay('confirm', '');
            
            loadParticipants();
            
        } catch (error) {
            console.error('Eroare la setarea parolei:', error);
            showMessage('Eroare la salvarea parolei: ' + error.message, 'error');
        }
    }
    
    function checkParticipantPassword() {
        const errorDiv = document.getElementById('participantPasswordError');
    
        if (!currentRecipient) {
            showMessage('Eroare la verificarea parolei!', 'error');
            return;
        }
    
        if (enterPasswordInput.length !== 4 || !/^\d{4}$/.test(enterPasswordInput)) {
            if (errorDiv) {
                errorDiv.textContent = 'Parola trebuie să fie de exact 4 cifre!';
                errorDiv.classList.remove('hidden');
            }
            return;
        }
    
        // Verifică parola folosind hash-ul
        const isValid = currentRecipient.passwordHash && 
                       window.verifyPassword(enterPasswordInput, currentRecipient.passwordHash);
    
        if (!isValid) {
            if (errorDiv) {
                errorDiv.textContent = 'Parolă incorectă!';
                errorDiv.classList.remove('hidden');
            }
            return;
        }
    
        hidePasswordForms();
        showParticipantMessagesList();
    
        if (errorDiv) errorDiv.classList.add('hidden');
        showMessage('Acces permis!', 'success');
    
        enterPasswordInput = '';
        updatePasswordDisplay('enter', '');
    }
    
    async function resetParticipantPassword() {
        if (!currentRecipient) return;
    
        if (!confirm('Sigur doriți să resetați parola? Va trebui să setați o parolă nouă.')) {
            return;
        }
    
        try {
            // Resetează local
            const participantIndex = participants.findIndex(p => p.id === currentRecipient.id);
            if (participantIndex !== -1) {
                participants[participantIndex].password = null;
                participants[participantIndex].passwordHash = null;
                participants[participantIndex].hasPassword = false;
                currentRecipient = participants[participantIndex];
                
                localStorage.setItem('participants', JSON.stringify(participants));
            }
    
            // Resetează în Firebase
            if (window.firebaseInitialized && window.resetParticipantPasswordInFirebase) {
                await window.resetParticipantPasswordInFirebase(currentRecipient.id);
                showMessage('Parola a fost resetată în cloud!', 'info');
            } else {
                showMessage('Parola a fost resetată local!', 'info');
            }
    
            adminPasswordInput = '';
            newPasswordInput = '';
            confirmPasswordInput = '';
            enterPasswordInput = '';
            
            updatePasswordDisplay('admin', '');
            updatePasswordDisplay('new', '');
            updatePasswordDisplay('confirm', '');
            updatePasswordDisplay('enter', '');
            
            checkParticipantAccess();
            loadParticipants();
            
        } catch (error) {
            console.error('Eroare la resetarea parolei:', error);
            showMessage('Eroare la resetarea parolei: ' + error.message, 'error');
        }
    }
    
    function hidePasswordForms() {
    const passwordSection = document.getElementById('participantPasswordSection');
    if (passwordSection) passwordSection.classList.add('hidden');
    }
    
    function showParticipantMessagesList() {
    const messagesList = document.getElementById('participantMessagesList');
    if (messagesList) {
        messagesList.classList.remove('hidden');
        displayParticipantMessages();
    }
    }
    
    function checkParticipantAccess() {
    if (!currentRecipient) return;

    const passwordSection = document.getElementById('participantPasswordSection');
    const messagesList = document.getElementById('participantMessagesList');
    const setPasswordForm = document.getElementById('setPasswordForm');
    const enterPasswordForm = document.getElementById('enterPasswordForm');
    const passwordStatus = document.getElementById('passwordStatus');

    if (!passwordSection || !messagesList || !setPasswordForm || !enterPasswordForm) return;

    passwordSection.classList.remove('hidden');
    messagesList.classList.add('hidden');
    setPasswordForm.classList.add('hidden');
    enterPasswordForm.classList.add('hidden');
    if (passwordStatus) passwordStatus.classList.add('hidden');

    // Reset password inputs
    adminPasswordInput = '';
    newPasswordInput = '';
    confirmPasswordInput = '';
    enterPasswordInput = '';

    updatePasswordDisplay('admin', '');
    updatePasswordDisplay('new', '');
    updatePasswordDisplay('confirm', '');
    updatePasswordDisplay('enter', '');

    // Verifică dacă participantul are parolă setată (folosind passwordHash)
    if (!currentRecipient.hasPassword || !currentRecipient.passwordHash) {
        showPasswordSetupStep1(); // Arată primul pas - setarea parolei
    } else {
        if (passwordStatus) passwordStatus.classList.remove('hidden');
        enterPasswordForm.classList.remove('hidden');
    }
}

// Funcții noi pentru gestionarea pașilor de setare parolă
function showPasswordSetupStep1() {
    // Ascunde toate formularele
    hideAllPasswordForms();
    
    // Arată doar formularul pentru setarea parolei noi
    const setPasswordForm = document.getElementById('setPasswordForm');
    if (setPasswordForm) {
        // Modifică conținutul pentru a arăta doar primul keypad
        setPasswordForm.innerHTML = `
            <p style="margin-bottom: 15px; color: #4c63d2; font-weight: 600;">
                Setează o parolă de 4 cifre:
            </p>
            
            <div class="keypad-container">
                <div class="password-display">
                    <span id="newPasswordDisplay" class="password-dots"></span>
                </div>
                
                <div class="numeric-keypad">
                    <button class="numeric-key" data-key="1" data-keypad="new">1</button>
                    <button class="numeric-key" data-key="2" data-keypad="new">2</button>
                    <button class="numeric-key" data-key="3" data-keypad="new">3</button>
                    <button class="numeric-key" data-key="4" data-keypad="new">4</button>
                    <button class="numeric-key" data-key="5" data-keypad="new">5</button>
                    <button class="numeric-key" data-key="6" data-keypad="new">6</button>
                    <button class="numeric-key" data-key="7" data-keypad="new">7</button>
                    <button class="numeric-key" data-key="8" data-keypad="new">8</button>
                    <button class="numeric-key" data-key="9" data-keypad="new">9</button>
                    <button class="numeric-key delete" data-key="delete" data-keypad="new">🔙 Șterge</button>
                    <button class="numeric-key zero" data-key="0" data-keypad="new">0</button>
                    <button class="numeric-key submit" data-key="submit" data-keypad="new" id="continueToConfirmBtn">➡️ Continuă</button>
                </div>
            </div>
        `;
        setPasswordForm.classList.remove('hidden');
        
        // Re-setup keypad events pentru noile butoane
        setupNumericKeypad();
    }
}

function showPasswordSetupStep2() {
    // Verifică dacă parola are 4 cifre
    if (newPasswordInput.length !== 4) {
        showMessage('Parola trebuie să fie de exact 4 cifre!', 'error');
        return;
    }
    
    // Ascunde toate formularele
    hideAllPasswordForms();
    
    // Arată formularul pentru confirmarea parolei
    const setPasswordForm = document.getElementById('setPasswordForm');
    if (setPasswordForm) {
        setPasswordForm.innerHTML = `
            <p style="margin-bottom: 15px; color: #4c63d2; font-weight: 600;">
                Confirmă parola de 4 cifre:
            </p>
            
            <div class="keypad-container">
                <div class="password-display">
                    <span id="confirmPasswordDisplay" class="password-dots"></span>
                </div>
                
                <div class="numeric-keypad">
                    <button class="numeric-key" data-key="1" data-keypad="confirm">1</button>
                    <button class="numeric-key" data-key="2" data-keypad="confirm">2</button>
                    <button class="numeric-key" data-key="3" data-keypad="confirm">3</button>
                    <button class="numeric-key" data-key="4" data-keypad="confirm">4</button>
                    <button class="numeric-key" data-key="5" data-keypad="confirm">5</button>
                    <button class="numeric-key" data-key="6" data-keypad="confirm">6</button>
                    <button class="numeric-key" data-key="7" data-keypad="confirm">7</button>
                    <button class="numeric-key" data-key="8" data-keypad="confirm">8</button>
                    <button class="numeric-key" data-key="9" data-keypad="confirm">9</button>
                    <button class="numeric-key delete" data-key="delete" data-keypad="confirm">🔙 Șterge</button>
                    <button class="numeric-key zero" data-key="0" data-keypad="confirm">0</button>
                    <button class="numeric-key submit" data-key="submit" data-keypad="confirm" id="setParticipantPasswordBtn">🔒 Setează</button>
                </div>
                
                <div class="action-buttons" style="margin-top: 15px;">
                    <button class="btn btn-secondary" id="backToStep1Btn">⬅️ Înapoi</button>
                </div>
            </div>
        `;
        setPasswordForm.classList.remove('hidden');
        
        // Re-setup keypad events și button events
        setupNumericKeypad();
        
        // Adaugă event listener pentru butonul de înapoi
        const backToStep1Btn = document.getElementById('backToStep1Btn');
        if (backToStep1Btn) {
            backToStep1Btn.addEventListener('click', function() {
                confirmPasswordInput = ''; // Reset confirmare
                updatePasswordDisplay('confirm', '');
                showPasswordSetupStep1();
            });
        }
    }
}

function hideAllPasswordForms() {
    const setPasswordForm = document.getElementById('setPasswordForm');
    const enterPasswordForm = document.getElementById('enterPasswordForm');
    const passwordStatus = document.getElementById('passwordStatus');
    
    if (setPasswordForm) setPasswordForm.classList.add('hidden');
    if (enterPasswordForm) enterPasswordForm.classList.add('hidden');
    if (passwordStatus) passwordStatus.classList.add('hidden');
}
    // ==================== MESSAGE MANAGEMENT ====================
    let isDrawing = false;
let lastX = 0;
let lastY = 0;

function setupDrawingCanvas() {
    const canvas = document.getElementById('drawingCanvas');
    const ctx = canvas.getContext('2d');
    
    // Setează stilul liniei
    ctx.strokeStyle = '#4c63d2';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    
    // Event listeners pentru desenare
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);
    
    canvas.addEventListener('touchstart', startDrawing);
    canvas.addEventListener('touchmove', draw);
    canvas.addEventListener('touchend', stopDrawing);
    
    const clearDrawingBtn = document.getElementById('clearDrawingBtn');
    if (clearDrawingBtn) {
        clearDrawingBtn.addEventListener('click', clearDrawing);
    }
}

function startDrawing(e) {
    isDrawing = true;
    [lastX, lastY] = [e.offsetX || e.touches[0].clientX, e.offsetY || e.touches[0].clientY];
}

function draw(e) {
    if (!isDrawing) return;
    
    const canvas = document.getElementById('drawingCanvas');
    const ctx = canvas.getContext('2d');
    
    const [x, y] = [e.offsetX || e.touches[0].clientX, e.offsetY || e.touches[0].clientY];
    
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(x, y);
    ctx.stroke();
    
    [lastX, lastY] = [x, y];
}

function stopDrawing() {
    isDrawing = false;
}

function clearDrawing() {
    const canvas = document.getElementById('drawingCanvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}


async function sendMessage() {
    // ...

    let photoUrl = null;
    
    if (currentPhotoData) {
        // ...
    } else {
        // Verifică dacă există un desen
        const canvas = document.getElementById('drawingCanvas');
        if (canvas && canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height).data.some(channel => channel !== 0)) {
            currentPhotoData = canvas.toDataURL('image/png');
            
            try {
                if (window.firebaseInitialized && window.uploadImageToFirebase) {
                    showMessage('Încărcăm desenul...', 'info');
                    const file = await base64ToFile(currentPhotoData, 'drawing.png');
                    photoUrl = await window.uploadImageToFirebase(file, currentRecipient.name);
                } else {
                    photoUrl = currentPhotoData;
                }
            } catch (error) {
                console.error('Eroare la încărcarea desenului:', error);
                showMessage('Eroare la încărcarea desenului, dar mesajul va fi trimis!', 'error');
            }
        }
    }
    
    // ...
}   

    async function sendPhotoOnly() {
    if (!currentPhotoData) {
        showMessage('Nu ai selectat nicio fotografie!', 'error');
        return;
    }
    
    if (!currentRecipient) {
        showMessage('Destinatarul este obligatoriu!', 'error');
        return;
    }
    
    const senderNameInput = document.getElementById('senderName');
    const anonymousInput = document.getElementById('anonymous');
    
    const senderName = senderNameInput ? senderNameInput.value.trim() : '';
    const anonymous = anonymousInput ? anonymousInput.checked : false;
    
    let photoUrl = null;
    
    try {
        if (window.firebaseInitialized && window.uploadImageToFirebase) {
            showMessage('Încărcăm poza...', 'info');
            const file = await base64ToFile(currentPhotoData);
            photoUrl = await window.uploadImageToFirebase(file, currentRecipient.name);
        } else {
            photoUrl = currentPhotoData;
        }
    } catch (error) {
        console.error('Eroare la încărcarea pozei:', error);
        showMessage('Eroare la încărcarea pozei!', 'error');
        return;
    }
    
    const message = {
        id: Date.now(),
        recipientId: currentRecipient.id,
        sender: anonymous ? 'Anonim' : (senderName || 'Anonim'),
        type: 'foto',
        content: '',
        photo: photoUrl,
        timestamp: new Date().toISOString()
    };
    
    messages.push(message);
    localStorage.setItem('messages', JSON.stringify(messages));
    
    if (window.firebaseInitialized && window.saveMessageToFirebase) {
        try {
            await window.saveMessageToFirebase(message, currentRecipient.name);
        } catch (error) {
            console.error('Eroare la salvarea mesajului în Firebase:', error);
        }
    }
    
    updateParticipantMessages();
    
    if (senderNameInput) senderNameInput.value = '';
    if (anonymousInput) anonymousInput.checked = false;
    clearPhotoData();
    
    const messageForm = document.getElementById('messageForm');
    if (messageForm) messageForm.classList.add('hidden');
    
    document.querySelectorAll('.quick-participant-item').forEach(i => {
        i.classList.remove('active');
    });
    
    showMessage('Fotografia a fost trimisă cu succes!', 'success');
    loadQuickParticipants();
    currentRecipient = null;
    }
    
    function updateParticipantMessages() {
    participants.forEach(participant => {
        participant.messages = messages.filter(msg => msg.recipientId === participant.id);
    });
    localStorage.setItem('participants', JSON.stringify(participants));
    }
    
    function cancelMessage() {
    const messageForm = document.getElementById('messageForm');
    if (messageForm) messageForm.classList.add('hidden');
    
    const senderNameInput = document.getElementById('senderName');
    const messageContentInput = document.getElementById('messageContent');
    const anonymousInput = document.getElementById('anonymous');
    
    if (senderNameInput) senderNameInput.value = '';
    if (messageContentInput) messageContentInput.value = '';
    if (anonymousInput) anonymousInput.checked = false;
    
    clearPhotoData();
    
    document.querySelectorAll('.quick-participant-item').forEach(i => {
        i.classList.remove('active');
    });
    
    currentRecipient = null;
    showMessage('Mesaj anulat!', 'info');
    }
    
    // ==================== AUTHENTICATION ====================
    function checkMessagesAccess() {
    if (isLoggedIn) {
        const passwordSection = document.getElementById('passwordSection');
        const messagesList = document.getElementById('messagesList');
        
        if (passwordSection) passwordSection.classList.add('hidden');
        if (messagesList) messagesList.classList.remove('hidden');
        
        displayAllMessages();
    } else {
        const passwordSection = document.getElementById('passwordSection');
        const messagesList = document.getElementById('messagesList');
        
        if (passwordSection) passwordSection.classList.remove('hidden');
        if (messagesList) messagesList.classList.add('hidden');
    }
    }
    
    // ==================== MESSAGE DISPLAY ====================
    function displayAllMessages() {
    const list = document.getElementById('messagesList');
    if (!list || !isLoggedIn) return;
    
    if (messages.length === 0) {
        list.innerHTML = '<p style="text-align: center; color: #666;">Nu există mesaje primite.</p>';
        return;
    }
    
    list.innerHTML = '<h3>Toate mesajele primite:</h3>';
    
    const messagesByParticipant = {};
    messages.forEach(msg => {
        const participant = participants.find(p => p.id === msg.recipientId);
        if (participant) {
            if (!messagesByParticipant[participant.id]) {
                messagesByParticipant[participant.id] = {
                    participant: participant,
                    messages: []
                };
            }
            messagesByParticipant[participant.id].messages.push(msg);
        }
    });
    
    Object.values(messagesByParticipant).forEach(group => {
        const participantDiv = document.createElement('div');
        participantDiv.style.marginBottom = '25px';
        participantDiv.style.padding = '15px';
        participantDiv.style.border = `3px solid ${group.participant.color}`;
        participantDiv.style.borderRadius = '15px';
        participantDiv.style.background = 'rgba(255, 255, 255, 0.8)';
        
        const participantName = group.participant.nickname ? 
            `${group.participant.name} (${group.participant.nickname})` : 
            group.participant.name;
        
        participantDiv.innerHTML = `
            <h4 style="color: ${group.participant.color}; margin-bottom: 12px; font-size: 16px;">
                📬 Mesaje pentru ${participantName} (${group.messages.length})
            </h4>
            <div class="messages-container">
                ${group.messages.map(msg => `
                    <div class="message" style="border-left: 4px solid ${group.participant.color};">
                        <div class="message-header">
                            <span class="message-sender">${getMessageTypeIcon(msg.type)} ${msg.sender}</span>
                            <span class="message-time">${new Date(msg.timestamp).toLocaleString('ro-RO')}</span>
                        </div>
                        <div class="message-type">${getMessageTypeName(msg.type)}</div>
                        <div class="message-content">${msg.content || 'Fără text'}</div>
                        ${msg.photo ? `
                            <div class="message-photo">
                                <img src="${msg.photo}" alt="Photo" onclick="openPhotoModal('${msg.photo}')" style="max-width: 150px; max-height: 120px; cursor: pointer;">
                            </div>
                        ` : ''}
                    </div>
                `).join('')}
            </div>
        `;
        
        list.appendChild(participantDiv);
    });
    }
    
    function displayParticipantMessages() {
    const list = document.getElementById('participantMessagesList');
    if (!list || !currentRecipient) return;
    
    const filteredMessages = messages.filter(m => m.recipientId === currentRecipient.id);
    
    if (filteredMessages.length === 0) {
        list.innerHTML = '<p style="text-align: center; color: #666;">Nu există mesaje primite pentru acest participant.</p>';
        return;
    }
    
    list.innerHTML = `<h3>Mesaje pentru ${currentRecipient.name} (${filteredMessages.length}):</h3>`;
    
    filteredMessages.forEach(msg => {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message';
        messageDiv.style.borderLeft = `4px solid ${currentRecipient.color}`;
        
        messageDiv.innerHTML = `
            <div class="message-header">
                <span class="message-sender">${getMessageTypeIcon(msg.type)} ${msg.sender}</span>
                <span class="message-time">${new Date(msg.timestamp).toLocaleString('ro-RO')}</span>
            </div>
            <div class="message-type">${getMessageTypeName(msg.type)}</div>
            <div class="message-content">${msg.content || 'Fără text'}</div>
            ${msg.photo ? `
                <div class="message-photo">
                    <img src="${msg.photo}" alt="Photo" onclick="openPhotoModal('${msg.photo}')" style="max-width: 200px; max-height: 150px; cursor: pointer;">
                </div>
            ` : ''}
        `;
        
        list.appendChild(messageDiv);
    });
    }
    // ==================== SHOW PARTICIPANT MESSAGES ====================
function showParticipantMessages() {
    if (!currentRecipient) {
        showMessage('Selectează mai întâi un participant!', 'error');
        return;
    }
    
    // Setează numele participantului în titlu
    const participantMessagesName = document.getElementById('participantMessagesName');
    if (participantMessagesName) {
        participantMessagesName.textContent = currentRecipient.name;
    }
    
    // Schimbă la tab-ul de mesaje participant
    showTab('participantMessages');
    
    // Verifică accesul (parolă)
    checkParticipantAccess();
}
    
// ==================== QR SCANNING - VERSIUNE RESCRISĂ ====================
let scannerInterval = null;

// Funcție pentru pornirea scanării
function startScanning() {
    const video = document.getElementById('video');
    const scannerSection = document.getElementById('scannerSection');
    const participantListSection = document.getElementById('participantListSection');
    
    if (!video) {
        showMessage('Elementul video nu a fost găsit!', 'error');
        return;
    }

    // Arată secțiunea de scanner și ascunde lista (dacă e cazul)
    if (scannerSection) scannerSection.style.display = 'block';
    if (participantListSection) participantListSection.style.display = 'none';

    // Configurare constrângeri video
    const constraints = {
        video: {
            facingMode: 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
        }
    };

    // Pornește camera
    navigator.mediaDevices.getUserMedia(constraints)
        .then(stream => {
            videoStream = stream;
            video.srcObject = stream;
            video.style.display = 'block';
            scanning = true;

            // Așteaptă ca video-ul să fie gata
            video.onloadedmetadata = () => {
                video.play();
                startQRDetection();
            };

            showMessage('Camera pornită! Scanează codul QR al unui participant...', 'info');
            
            // Actualizează UI
            const startScanBtn = document.getElementById('startScanBtn');
            const stopScanBtn = document.getElementById('stopScanBtn');
            if (startScanBtn) startScanBtn.style.display = 'none';
            if (stopScanBtn) stopScanBtn.style.display = 'inline-block';
        })
        .catch(err => {
            console.error('Eroare la pornirea camerei:', err);
            handleCameraError(err);
        });
}

// Funcție pentru gestionarea erorilor de cameră
function handleCameraError(error) {
    let errorMessage = 'Nu pot accesa camera!';
    
    if (error.name === 'NotAllowedError') {
        errorMessage = 'Accesul la cameră a fost refuzat. Permite accesul din setările browser-ului.';
    } else if (error.name === 'NotFoundError') {
        errorMessage = 'Nu s-a găsit nicio cameră pe acest dispozitiv.';
    } else if (error.name === 'NotReadableError') {
        errorMessage = 'Camera este folosită de altă aplicație.';
    }
    
    showMessage(errorMessage, 'error');
    
    // Arată din nou lista de participanți
    showParticipantsList();
}

// Funcție pentru detectarea QR
function startQRDetection() {
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    
    if (!video || !canvas) return;
    
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    // Setează dimensiuni fixe pentru canvas
    canvas.width = 640;
    canvas.height = 480;
    
    // Funcție de scanare continuă
    const scan = () => {
        if (!scanning) return;
        
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
            // Desenează și scalează imaginea
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // Obține datele imaginii
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Detectează QR code
            detectQRCode(imageData);
        }
        
        // Continuă scanarea la fiecare 100ms
        setTimeout(() => requestAnimationFrame(scan), 100);
    };
    
    // Începe scanarea
    scan();
}
// Funcție pentru detectarea efectivă a QR
function detectQRCode(imageData) {
    try {
        // Dacă jsQR este disponibil, folosește-l
        if (typeof jsQR !== 'undefined') {
            const code = jsQR(imageData.data, imageData.width, imageData.height, {
                inversionAttempts: "dontInvert",
            });
            
            if (code && code.data) {
                processQRCode(code.data);
                return;
            }
        }
        
        // Altfel, încearcă detectarea custom pentru QR-urile generate
        const customData = detectCustomQRPattern(imageData);
        if (customData) {
            processQRCode(customData);
        }
    } catch (error) {
        console.error('Eroare la detectarea QR:', error);
    }
}

// Funcție simplificată pentru detectarea pattern-ului QR custom
function detectCustomQRPattern(imageData) {
    const { data, width, height } = imageData;
    
    // Verifică dacă are colțurile QR
    if (!checkForQRCorners(data, width, height)) {
        return null;
    }
    
    // Încearcă să extragă ID-ul din zona centrală
    const cellSize = Math.floor(width / 25);
    const centerStart = 10;
    let detectedId = '';
    
    // Citește cifrele codificate în centru
    for (let i = 0; i < 5; i++) {
        let digit = 0;
        for (let b = 0; b < 4; b++) {
            const x = (centerStart + i) * cellSize + cellSize / 2;
            const y = (centerStart + b) * cellSize + cellSize / 2;
            
            if (x < width && y < height) {
                const idx = (Math.floor(y) * width + Math.floor(x)) * 4;
                const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                
                if (brightness < 128) {
                    digit |= (1 << b);
                }
            }
        }
        
        if (digit <= 9) {
            detectedId += digit.toString();
        }
    }
    
    if (detectedId.length >= 3) {
        // Caută participant cu ID care începe cu cifrele detectate
        const participant = participants.find(p => 
            p.id.toString().startsWith(detectedId)
        );
        
        if (participant) {
            return `participant:${participant.id}`;
        }
    }
    
    return null;
}
// Verifică prezența colțurilor QR
function checkForQRCorners(data, width, height) {
    // Verificare simplificată - caută zone cu contrast mare în colțuri
    const cornerSize = Math.floor(Math.min(width, height) / 10);
    let cornersFound = 0;
    
    // Verifică colțul stânga-sus
    if (hasHighContrast(data, width, 0, 0, cornerSize)) cornersFound++;
    
    // Verifică colțul dreapta-sus  
    if (hasHighContrast(data, width, width - cornerSize, 0, cornerSize)) cornersFound++;
    
    // Verifică colțul stânga-jos
    if (hasHighContrast(data, width, 0, height - cornerSize, cornerSize)) cornersFound++;
    
    return cornersFound >= 2;
}

// Verifică contrastul într-o zonă
function hasHighContrast(data, width, startX, startY, size) {
    let blackPixels = 0;
    let whitePixels = 0;
    
    for (let y = startY; y < startY + size && y < data.length / (width * 4); y += 5) {
        for (let x = startX; x < startX + size && x < width; x += 5) {
            const idx = (y * width + x) * 4;
            const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            
            if (brightness < 128) blackPixels++;
            else whitePixels++;
        }
    }
    
    // Verifică dacă există atât pixeli negri cât și albi (contrast)
    return blackPixels > 10 && whitePixels > 10;
}

// Procesează codul QR detectat
function processQRCode(qrData) {
    console.log('QR Code detectat:', qrData);
    
    let participant = null;
    
    // Verifică diferite formate de QR
    if (qrData.startsWith('participant:')) {
        // Format: participant:ID
        const participantId = parseInt(qrData.replace('participant:', ''));
        participant = participants.find(p => p.id === participantId);
    } else if (/^\d+$/.test(qrData)) {
        // Format: doar ID numeric
        participant = participants.find(p => p.id === parseInt(qrData));
    } else {
        // Format: nume sau text
        participant = participants.find(p => 
            p.name.toLowerCase() === qrData.toLowerCase() ||
            (p.nickname && p.nickname.toLowerCase() === qrData.toLowerCase())
        );
    }
    
    if (participant) {
        // Oprește scanarea și selectează participantul
        stopScanning();
        selectParticipantFromQR(participant);
    } else {
        // Nu s-a găsit participantul - continuă scanarea
        console.log('Participant negăsit pentru QR:', qrData);
    }
}

// Selectează participantul după scanare
function selectParticipantFromQR(participant) {
    currentRecipient = participant;
    
    // Actualizează UI cu numele participantului
    const targetName = document.getElementById('targetName');
    const participantMessagesName = document.getElementById('participantMessagesName');
    
    if (targetName) targetName.textContent = participant.name;
    if (participantMessagesName) participantMessagesName.textContent = participant.name;
    
    // Afișează formularul de mesaj
    const messageForm = document.getElementById('messageForm');
    if (messageForm) {
        messageForm.classList.remove('hidden');
        messageForm.scrollIntoView({ behavior: 'smooth' });
    }
    
    // Evidențiază participantul în listă (dacă e vizibilă)
    highlightParticipantInList(participant.id);
    
    // Feedback
    showMessage(`✅ Participant selectat: ${participant.name}`, 'success');
    
    if (navigator.vibrate) {
        navigator.vibrate([100, 50, 100]);
    }
}

// Oprește scanarea
function stopScanning() {
    scanning = false;
    
    // Oprește stream-ul video
    if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
        videoStream = null;
    }
    
    // Ascunde video și arată lista
    const video = document.getElementById('video');
    const scannerSection = document.getElementById('scannerSection');
    
    if (video) {
        video.style.display = 'none';
        video.srcObject = null;
    }
    
    if (scannerSection) {
        scannerSection.style.display = 'none';
    }
    
    // Actualizează butoanele
    const startScanBtn = document.getElementById('startScanBtn');
    const stopScanBtn = document.getElementById('stopScanBtn');
    
    if (startScanBtn) startScanBtn.style.display = 'inline-block';
    if (stopScanBtn) stopScanBtn.style.display = 'none';
    
    // Arată din nou lista de participanți
    showParticipantsList();
    
    showMessage('Camera oprită!', 'info');
}

// Arată lista de participanți
function showParticipantsList() {
    const participantListSection = document.getElementById('participantListSection');
    const quickParticipantList = document.getElementById('quickParticipantList');
    
    if (participantListSection) {
        participantListSection.style.display = 'block';
    }
    
    // Re-încarcă lista de participanți
    if (quickParticipantList) {
        loadQuickParticipants();
    }
}

// Evidențiază participantul selectat în listă
function highlightParticipantInList(participantId) {
    // Elimină selecția anterioară
    document.querySelectorAll('.quick-participant-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Găsește și evidențiază participantul
    document.querySelectorAll('.quick-participant-item').forEach(item => {
        const itemText = item.textContent.trim();
        const participant = participants.find(p => p.id === participantId);
        
        if (participant && itemText.includes(participant.name)) {
            item.classList.add('active');
            item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    });
}

// Simulare scanare QR (pentru teste)
function simulateQRScan() {
    if (participants.length === 0) {
        showMessage('Nu există participanți pentru simulare!', 'error');
        return;
    }
    
    // Oprește scanarea dacă e activă
    if (scanning) {
        stopScanning();
    }
    
    // Selectează un participant aleatoriu
    const randomIndex = Math.floor(Math.random() * participants.length);
    const randomParticipant = participants[randomIndex];
    
    // Simulează detectarea QR
    showMessage('🎲 Simulare scanare QR...', 'info');
    
    setTimeout(() => {
        selectParticipantFromQR(randomParticipant);
    }, 500);
}

// Toggle între scanare și listă
function toggleScannerView() {
    if (scanning) {
        stopScanning();
    } else {
        startScanning();
    }
}

// Cleanup la închiderea paginii
window.addEventListener('beforeunload', () => {
    if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
    }
});  
    // ==================== EVENT LISTENERS ====================
    function setupEventListeners() {
    const addParticipantBtn = document.getElementById('addParticipantBtn');
    if (addParticipantBtn) {
        addParticipantBtn.addEventListener('click', addParticipant);
    }
    
    const clearAllDataBtn = document.getElementById('clearAllDataBtn');
    if (clearAllDataBtn) {
        clearAllDataBtn.addEventListener('click', clearAllData);
    }
    
    const setParticipantPasswordBtn = document.getElementById('setParticipantPasswordBtn');
    if (setParticipantPasswordBtn) {
        setParticipantPasswordBtn.addEventListener('click', setParticipantPassword);
    }
    
    const checkParticipantPasswordBtn = document.getElementById('checkParticipantPasswordBtn');
    if (checkParticipantPasswordBtn) {
        checkParticipantPasswordBtn.addEventListener('click', checkParticipantPassword);
    }
    
    const resetParticipantPasswordBtn = document.getElementById('resetParticipantPasswordBtn');
    if (resetParticipantPasswordBtn) {
        resetParticipantPasswordBtn.addEventListener('click', resetParticipantPassword);
    }
    
    const checkAdminPasswordBtn = document.getElementById('checkAdminPasswordBtn');
    if (checkAdminPasswordBtn) {
        checkAdminPasswordBtn.addEventListener('click', checkAdminPasswordFromKeypad);
    }
    
    const sendMessageBtn = document.getElementById('sendMessageBtn');
    if (sendMessageBtn) {
        sendMessageBtn.addEventListener('click', sendMessage);
    }
    
    const sendPhotoOnlyBtn = document.getElementById('sendPhotoOnlyBtn');
    if (sendPhotoOnlyBtn) {
        sendPhotoOnlyBtn.addEventListener('click', sendPhotoOnly);
    }
    
    const cancelMessageBtn = document.getElementById('cancelMessageBtn');
    if (cancelMessageBtn) {
        cancelMessageBtn.addEventListener('click', cancelMessage);
    }
    
    const showParticipantMessagesBtn = document.getElementById('showParticipantMessagesBtn');
    if (showParticipantMessagesBtn) {
        showParticipantMessagesBtn.addEventListener('click', showParticipantMessages);
    }
    
    const startScanBtn = document.getElementById('startScanBtn');
    if (startScanBtn) {
        startScanBtn.addEventListener('click', startScanning);
    }
    
    const stopScanBtn = document.getElementById('stopScanBtn');
    if (stopScanBtn) {
        stopScanBtn.addEventListener('click', stopScanning);
    }
    
    const simulateQRBtn = document.getElementById('simulateQRBtn');
    if (simulateQRBtn) {
        simulateQRBtn.addEventListener('click', simulateQRScan);
    }
    
    const backToScanBtn = document.getElementById('backToScanBtn');
    if (backToScanBtn) {
        backToScanBtn.addEventListener('click', () => showTab('scan'));
    }
    
    const participantNameInput = document.getElementById('participantName');
    if (participantNameInput) {
        participantNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addParticipant();
            }
        });
    }
    
    const messageContentInput = document.getElementById('messageContent');
    if (messageContentInput) {
        messageContentInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    }

    const downloadQRCodesBtn = document.getElementById('downloadQRCodesBtn');
if (downloadQRCodesBtn) {
    downloadQRCodesBtn.addEventListener('click', downloadQRCodes);
}
    }
    
    // ==================== CLEANUP ====================
    function cleanup() {
    if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
        videoStream = null;
    }
    scanning = false;
    }
    
    // ==================== INITIALIZATION ====================
    document.addEventListener('DOMContentLoaded', async function() {
        // Încarcă mai întâi din localStorage
        participants = JSON.parse(localStorage.getItem('participants')) || [];
        messages = JSON.parse(localStorage.getItem('messages')) || [];
    
        // Apoi încearcă să încarce din Firebase
        if (window.firebaseInitialized) {
            try {
                showMessage('Încărcăm datele din cloud...', 'info');
                
                const firebaseParticipants = await window.loadParticipantsFromFirebaseWithPasswords();
                const firebaseMessages = await window.loadMessagesFromFirebase();
                
                if (firebaseParticipants.length > 0) {
                    participants = firebaseParticipants;
                    localStorage.setItem('participants', JSON.stringify(participants));
                }
                
                if (firebaseMessages.length > 0) {
                    messages = firebaseMessages;
                    localStorage.setItem('messages', JSON.stringify(messages));
                }
                
                showMessage('Datele au fost sincronizate!', 'success');
                
                // Pornește sincronizarea automată la fiecare 30 secunde
                setInterval(window.autoSyncWithPasswords, 30000);
                
            } catch (error) {
                console.error('Eroare la sincronizarea cu cloud:', error);
                showMessage('Folosim datele locale. Eroare cloud: ' + error.message, 'info');
            }
        }
    
        // Asigură-te că toți participanții au proprietățile necesare pentru parole
        participants.forEach(participant => {
            if (participant.password === undefined) {
                participant.password = null;
            }
            if (participant.hasPassword === undefined) {
                participant.hasPassword = false;
            }
            if (participant.passwordHash === undefined) {
                participant.passwordHash = null;
            }
        });
    
        localStorage.setItem('participants', JSON.stringify(participants));
    
        updateParticipantMessages();
        setupEventListeners();
        setupNumericKeypad();
        setupPhotoUpload();
        setupPhotoModal();
        setupDrawingCanvas();
    
        if (password && isLoggedIn) {
            const passwordSection = document.getElementById('passwordSection');
            const messagesList = document.getElementById('messagesList');
            
            if (passwordSection) passwordSection.classList.add('hidden');
            if (messagesList) messagesList.classList.remove('hidden');
        }
    
        loadParticipants();
        loadQuickParticipants();
        showMessage('Aplicația a fost încărcată cu succes!', 'success');
    });
    
    window.addEventListener('beforeunload', cleanup);
    
    document.addEventListener('touchstart', function(e) {
    if (e.touches.length > 1) {
        e.preventDefault();
    }
    });
    
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(e) {
    const now = (new Date()).getTime();
    if (now - lastTouchEnd <= 300) {
        e.preventDefault();
    }
    lastTouchEnd = now;
    }, false);
    
    window.participants = participants;
    window.messages = messages;
    window.showTab = showTab;
    window.deleteParticipant = deleteParticipant;
    window.openPhotoModal = openPhotoModal;
    
    // Sincronizare când se schimbă visibility-ul paginii
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden && window.autoSyncWithPasswords) {
            // Când utilizatorul revine pe tab, sincronizează
            setTimeout(window.autoSyncWithPasswords, 1000);
        }
    });
    
    // Sincronizare când se schimbă focus-ul pe fereastră
    window.addEventListener('focus', function() {
        if (window.autoSyncWithPasswords) {
            setTimeout(window.autoSyncWithPasswords, 1000);
        }
    });
    </script>

